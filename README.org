#+options: H:6 arch:headline author:t
#+options: date:t e:t
#+options: email:t expand-links:t f:t inline:t num:t p:nil pri:nil prop:nil
#+options: stat:nil tags:nil tasks:nil tex:t timestamp:t title:t toc:nil
#+title: README
#+date: <2024-07-11 Thu>
#+author: Lucas Elvira Mart√≠n
#+email: lucaselvira96@gmail.com
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 29.3 (Org mode 9.7-pre)
#+cite_export:
#+EXPORT_FILE_NAME: README
* Simple calculator

This application is a toy tool to parse a string and operate with it to return
the result of make the operation. The main porpoise of this exercise is to train
my knowledge about the languages

* Start the project

In this case, I use cabal as project management for haskell, so to start the
configuration, I ran the command ~cabal init~ and setup the configuration file
following the instruction from [[https://learn-haskell.blog/][Learn haskell by building a blog generator]]. This
resource also help me with some process that have in common with my idea of the
calculator.

** cabal file
The cabal file contains the meta information about the project, so it is
important to follow some rules like the names should match.

*** Information about the project

The first part contains the information about the project, with the name,
description, version, and so on

#+INCLUDE: "calc.cabal" src cabal :range-begin "MetaInfo" :range-end "-MetaInfo" :lines "4-13"

When we define export targets, they could share some configuration. To make it,
we can define a ~common~ block that will be named ~common-settings~ with the
compiler and the flags

#+INCLUDE: "calc.cabal" src cabal :range-begin "CommonSettings" :range-end "-CommonSettings" :lines "16-20"

*** The library target
This is not necessary, but could be a good practice. I want to build a lexer
parser for a dummy calculator. But also, it could be used in another projects,
so all the logic will be placed in the ~src~ folder, and will be called from the
~app~ folder.

In the ~library target~ we define:
- Exposed modules (Modules that need to be compiled and accessible
- Where is the content of the code, in this case the src folder
- The dependencies used by the program
- Other modules that will be empty at this moment

#+INCLUDE: "calc.cabal" src cabal :range-begin "Library" :range-end "-Library" :lines "23-38"

*** Executable target
This is the name of the application. In this block, we define the name of the
executable and the resources it will need. As we did with the ~library target~, we
configure it to use the common settings and add the our library as a dependency.
Also, we add a new flag to the compilation process and set the folder with the
code. In this case the ~app~ folder.

#+INCLUDE: "calc.cabal" src cabal :range-begin "Executable" :range-end "-Executable" :lines "41-50"

*** Test target

I will try to follow as longer as I can a TDD methodology, so this part I thing
will be really important, the test block. In this case I use the Spec library
that allows me define the test parts. One thing that is very important is to add
all the modules which have the test to the build-depends, otherwise, they
neither will be compiled or executed.

#+INCLUDE: "calc.cabal" src cabal :range-begin "TestBlock" :range-end "-TestBlock" :lines "53-72"

