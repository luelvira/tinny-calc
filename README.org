#+options: H:6 arch:headline author:t
#+options: date:t e:t
#+options: email:t expand-links:t f:t inline:t num:t p:nil pri:nil prop:nil
#+options: stat:nil tags:nil tasks:nil tex:t timestamp:t title:t toc:nil
#+title: README
#+date: <2024-07-11 Thu>
#+author: Lucas Elvira Mart√≠n
#+email: lucaselvira96@gmail.com
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 29.3 (Org mode 9.7-pre)
#+cite_export:
#+EXPORT_FILE_NAME: README
* Simple calculator

This application is a toy tool to parse a string and operate with it to return
the result of make the operation. The main porpoise of this exercise is to train
my knowledge about the languages

* Start the project

In this case, I use cabal as project management for haskell, so to start the
configuration, I ran the command ~cabal init~ and setup the configuration file
following the instruction from [[https://learn-haskell.blog/][Learn haskell by building a blog generator]]. This
resource also help me with some process that have in common with my idea of the
calculator.

** cabal file
The cabal file contains the meta information about the project, so it is
important to follow some rules like the names should match.

*** Information about the project

The first part contains the information about the project, with the name,
description, version, and so on

#+INCLUDE: "calc.cabal" src cabal :range-begin "MetaInfo" :range-end "-MetaInfo" :lines "4-13"

When we define export targets, they could share some configuration. To make it,
we can define a ~common~ block that will be named ~common-settings~ with the
compiler and the flags

#+INCLUDE: "calc.cabal" src cabal :range-begin "CommonSettings" :range-end "-CommonSettings" :lines "16-20"

*** The library target
This is not necessary, but could be a good practice. I want to build a lexer
parser for a dummy calculator. But also, it could be used in another projects,
so all the logic will be placed in the ~src~ folder, and will be called from the
~app~ folder.

In the ~library target~ we define:
- Exposed modules (Modules that need to be compiled and accessible
- Where is the content of the code, in this case the src folder
- The dependencies used by the program
- Other modules that will be empty at this moment

#+INCLUDE: "calc.cabal" src cabal :range-begin "Library" :range-end "-Library" :lines "23-40"

*** Executable target
This is the name of the application. In this block, we define the name of the
executable and the resources it will need. As we did with the ~library target~, we
configure it to use the common settings and add the our library as a dependency.
Also, we add a new flag to the compilation process and set the folder with the
code. In this case the ~app~ folder.

#+INCLUDE: "calc.cabal" src cabal :range-begin "Executable" :range-end "-Executable" :lines "43-52"

*** Test target

I will try to follow as longer as I can a TDD methodology, so this part I thing
will be really important, the test block. In this case I use the Spec library
that allows me define the test parts. One thing that is very important is to add
all the modules which have the test to the build-depends, otherwise, they
neither will be compiled or executed.

#+INCLUDE: "calc.cabal" src cabal :range-begin "TestBlock" :range-end "-TestBlock" :lines "55-75"



* The lexer

This is the first part of the parser. This module define the tokens and evaluate
if the string could be represent with a custom grammar.

The tokens are defined as:
#+INCLUDE: "src/Calc/Lexer/Internal.hs" src haskell :range-begin "DefineTokens" :range-end "-DefineTokens" :lines "51-64"

Some of these tokens will not be used at the moment, but could be used in future versions.

And the grammar is:
#+INCLUDE: "src/Calc/Lexer/Internal.hs" src haskell :range-begin "DefineGrammar" :range-end "-DefineGrammar" :lines "13-38"

A more clear version of the grammar was done with data type

#+INCLUDE: "src/Calc/Lexer/Internal.hs" src haskell :range-begin "DefineTypes" :range-end "-DefineTypes" :lines "67-83"

** Tokens

The most reduce piece of the grammar is the factor, which is only a number. The
first function will tray to extract the number from the string and returns it
and the string remainder

#+INCLUDE: "src/Calc/Lexer/Internal.hs" src haskell :range-begin "EvalFactorFunction" :range-end "-EvalFactorFunction" :lines "227-232"

Next, a term is composed by a ~Factor~ and a list of ~(MulOp, factor)~. So, I split
the process in two functions.

The first one will be in charge of iter over the string and returns the full
list of tuples

#+INCLUDE: "src/Calc/Lexer/Internal.hs" src haskell :range-begin "EvalTermFunction'" :range-end "-EvalTermFunction'" :lines "207-223"

With this auxiliary function, I can write the ~evalTerm~
#+INCLUDE: "src/Calc/Lexer/Internal.hs" src haskell :range-begin "EvalTermFunction" :range-end "-EvalTermFunction" :lines "195-204"

Following the same approach, I write the last rule ~expression~
#+INCLUDE: "src/Calc/Lexer/Internal.hs" src haskell :range-begin "EvalTermFunction" :range-end "-EvalTermFunction" :lines "195-204"
